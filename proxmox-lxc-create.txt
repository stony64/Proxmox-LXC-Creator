
### cli.func

#!/usr/bin/env bash
###############################################################################
# cli.func – CLI-Parameterverarbeitung für Proxmox LXC-Ersteller
# Version:    2.7.6
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Dieses Modul verarbeitet Kommandozeilenargumente für das Hauptskript
# 'create_ct_install.sh'. Unterstützt derzeit folgende Parameter:
#
# Unterstützte Parameter (DE):
#   --hostname <name>   Setzt den Hostnamen direkt (ohne Dialog)
#   --dry-run           Zeigt die Konfiguration zur Kontrolle, ohne einen
#                       Container zu erstellen
#   --help              Zeigt diese Hilfe
#
# Supported CLI parameters (EN):
#   --hostname <name>   Sets the container hostname directly (skip prompt)
#   --dry-run           Shows configuration preview but does not create a container
#   --help              Displays this help message
#
# Vorbereitung auf zukünftige Parameter wie:
#   --memory <MB>, --cores <int>, --template <file>, --ssh-key <file>, ...
#
###############################################################################

### Kommandozeilenargumente parsen
### Parse CLI parameters
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --hostname)
                shift
                if [[ $# -gt 0 && ! "$1" =~ ^-- ]]; then
                    PARAM_HOSTNAME="$1"
                    log "CLI: Hostname gesetzt auf '$PARAM_HOSTNAME'"
                else
                    exit_with_log "Fehlender Wert für --hostname"
                fi
                ;;
            --dry-run)
                PARAM_DRYRUN=true
                log "CLI: Dry-Run aktiviert"
                ;;
            --help | -h)
                print_cli_help
                exit 0
                ;;
            *)
                log_error "Unbekannter Parameter: $1"
                log "Benutze '--help' für eine Liste unterstützter Optionen."
                exit 1
                ;;
        esac
        shift
    done
}

### Hilfe-/Übersichtsanzeige für CLI-Parameter
print_cli_help() {
    echo ""
    echo "Verfügbare CLI-Parameter:"
    echo "  --hostname <name>   Setzt den Container-Hostname direkt"
    echo "  --dry-run           Zeigt Konfiguration, ohne Container zu erstellen"
    echo "  --help, -h          Zeigt diese Hilfe"
    echo ""
    echo "Beispiel:"
    echo "  ./create_ct_install.sh --hostname my-lxc"
    echo ""
    echo "Weitere Parameter in Vorbereitung:"
    echo "  --memory <MB>       (z. B. 1024)"
    echo "  --cores <Zahl>      (z. B. 2)"
    echo "  --template <Datei>  (Pfad zur LXC-Template-Datei)"
    echo "  --ssh-key <Datei>   (SSH Public Key für root einfügen)"
    echo ""
}


### container.func

#!/usr/bin/env bash
###############################################################################
# container.func – Container-Erstellung für Proxmox LXC
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Diese Datei enthält die Funktion zur Erstellung eines LXC-Containers mit pct.
# Sie nutzt die vorbereiteten Werte aus den vorherigen Eingaben und übernimmt
# die vollständige Erstellung, Konfiguration, Start und Tagging des Containers.
#
# Description (English):
# This file contains the function for creating an LXC container using pct.
# It consumes preconfigured global variables and executes creation, configuration,
# automated startup and tagging of the container.
#
###############################################################################

### LXC-Container erstellen und starten
### Create and start LXC container
create_container() {
    log "${MSG[creating]}"

    # Pflichtvariablen prüfen
    for var in OSType CT_ID OSTEMPLATE CT_HOSTNAME CT_CORES CT_MEMORY CT_IPV4 CT_IPV6 \
            ROOTFS_SIZE CT_PASSWORD STORAGE NET_BRIDGE GATEWAY_IPV4 GATEWAY_IPV6; do
        if [[ -z "${!var:-}" ]]; then
            exit_with_log "Fehler: $var ist nicht gesetzt."
        fi
    done

    pct create "$CT_ID" "$OSTEMPLATE" \
        --hostname "$CT_HOSTNAME" \
        --arch amd64 \
        --cores "$CT_CORES" \
        --memory "$CT_MEMORY" \
        --swap 512 \
        --features nesting=1 \
        --unprivileged 0 \
        --net0 "name=eth0,bridge=${NET_BRIDGE},ip=${CT_IPV4}/24,gw=${GATEWAY_IPV4},ip6=${CT_IPV6}/64,gw6=${GATEWAY_IPV6}" \
        --rootfs "$STORAGE:$ROOTFS_SIZE" \
        --password "$CT_PASSWORD" \
        --ostype "$OSType" \
        --description "Erstellt am $(date '+%d.%m.%Y %H:%M:%S')"

    log_success "${MSG[created]} (CT-ID: $CT_ID)"

    pct start "$CT_ID"
    log_success "${MSG[started]} (CT-ID: $CT_ID)"

    pct set "$CT_ID" --tags "$OSType"
    log "Tag gesetzt: $OSType"
}


### create_ct_install.sh

#!/usr/bin/env bash
###############################################################################
# Proxmox LXC Container Creator – Hauptskript / Main Script
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Dieses Skript automatisiert die Erstellung und Konfiguration von LXC-
# Containern auf einem Proxmox-Host. Es lädt modular externe Funktionen
# (*.func), nutzt whiptail für interaktive Eingaben und enthält Schritte zur
# Netzwerkkonfiguration, Passwortvergabe, SSH-Key-Setup und Systempflege.
#
# Description (English):
# This script automates the creation and configuration of LXC containers on a
# Proxmox host. It sources modular function files (*.func), uses whiptail for
# interactive input and covers network setup, password management, SSH key
# integration, and system updates.
#
###############################################################################

# Exit bei Fehler, nicht gesetzten Variablen oder Pipefehler
set -euo pipefail

################################################################################
# 1 – Globale Einstellungen / Global configuration
################################################################################

readonly STORAGE="FP1000GB"
readonly TEMPLATE_PATH="/mnt/FP1000GB/template/cache"

# shellcheck disable=SC2034
readonly LOGFILE="/root/repos/proxmox-lxc-creator/lxc_create_$(date +'%Y%m%d_%H%M%S').log"

readonly NET_BRIDGE="vmbr2"
readonly BASE_IPV4="192.168.10."
readonly BASE_IPV6="fd00:1234:abcd:10::"
readonly GATEWAY_IPV4="192.168.10.1"
readonly GATEWAY_IPV6="fd00:1234:abcd:10:3ea6:2fff:fe65:8fa7"

# Laufzeitvariablen / Runtime variables
CT_ID="" CT_HOSTNAME="" CT_PASSWORD="" CT_CORES="" CT_MEMORY="" ROOTFS_SIZE=""
TEMPLATE_FILE="" OSTEMPLATE="" OSType="" SSH_PUBKEY="" LAPTOP_KEY_COMMENT=""
CT_IPV4="" CT_IPV6="" PARAM_HOSTNAME=""

################################################################################
# 2 – Funktionsmodule laden / Load function modules
################################################################################

# shellcheck source=./logging.func
source "$(dirname "$0")/logging.func"
trap 'log_error "FEHLER in Zeile $LINENO / ERROR at line $LINENO"; exit 2' ERR

# shellcheck source=./translation.func
set +ux
source "$(dirname "$0")/translation.func"
load_translations
log "Sprache geladen: $LANGCODE"
log "MSG[mode_title]: '${MSG[mode_title]}'"

for func in security dialogs cli input network ssh container system dotfiles summary; do
    # shellcheck source=./$func.func
    source "$(dirname "$0")/$func.func"
done

set -u

################################################################################
# 3 – Hauptablauf / Main workflow
################################################################################

main() {
    log "PARAM_DRYRUN ist: ${PARAM_DRYRUN:-nicht gesetzt}"
    parse_args "$@"
    log "Parse args abgeschlossen"
    check_root
    log "check root abgeschlossen"
    check_bash_version
    log "BASH_VERSINFO: ${BASH_VERSINFO[@]:-(leer)}"
    log "check_bash_version abgeschlossen"
    check_required_tools
    log "check_required_tools abgeschlossen"
    check_directory_exists "$TEMPLATE_PATH"
    log "check_directory_exists abgeschlossen: $TEMPLATE_PATH"
    select_mode
    log "select_mode abgeschlossen"
    find_next_ctid
    log "find_next_ctid abgeschlossen: CT_ID=$CT_ID"
    input_hostname
    log "input_hostname abgeschlossen: CT_HOSTNAME=$CT_HOSTNAME"
    input_password
    log "input_password abgeschlossen: CT_PASSWORD=******"
    select_template
    log "select_template abgeschlossen: TEMPLATE_FILE=$TEMPLATE_FILE"
    detect_ostype_from_template
    log "detect_ostype_from_template abgeschlossen: OSTEMPLATE=$OSTEMPLATE, OSType=$OSType"
    input_rootfs_size
    log "input_rootfs_size abgeschlossen: ROOTFS_SIZE=$ROOTFS_SIZE"
    input_resources
    log "input_resources abgeschlossen: CT_CORES=$CT_CORES, CT_MEMORY=$CT_MEMORY"
    get_container_ip
    log "get_container_ip abgeschlossen: CT_IPV4=$CT_IPV4, CT_IPV6=$CT_IPV6"
    ask_for_laptop_key_comment
    log "ask_for_laptop_key_comment abgeschlossen: LAPTOP_KEY_COMMENT=$LAPTOP_KEY_COMMENT"
    extract_laptop_key
    log "extract_laptop_key abgeschlossen: SSH_PUBKEY=${SSH_PUBKEY:-nicht gesetzt}"

    # Dry-Run? Dann Vorschau anzeigen und beenden
    #[[ "${1:-}" == "--dry-run" ]] && { dry_run_preview; exit 0; }
    if [[ "${PARAM_DRYRUN:-false}" == "true" ]]; then
        dry_run_preview
        exit 0
    fi
    log "Dry-Run abgeschlossen"

    prepare_ssh_key_prestart
    log "prepare_ssh_key_prestart abgeschlossen: SSH_PUBKEY=${SSH_PUBKEY:-nicht gesetzt}"
    create_container
    log "Container mit ID $CT_ID erstellt."
    finalize_ssh_key_after_start
    log "finalize_ssh_key_after_start abgeschlossen: SSH_PUBKEY=${SSH_PUBKEY:-nicht gesetzt}"
    configure_locales
    log "configure_locales abgeschlossen"
    update_container
    log "update_container abgeschlossen"
    clone_dotfiles_in_container
    log "clone_dotfiles_in_container abgeschlossen"
    print_summary
    log "print_summary abgeschlossen"
}
set -x
main "$@"


### dialogs.func

#!/usr/bin/env bash
###############################################################################
# dialogs.func – Lokalisierte Whiptail-Titel für Proxmox LXC Creator
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Dieses Modul liefert Fenster-Titel (dialog_title) für alle interaktiven
# Whiptail-Dialoge, abhängig von Sprache und Zweck. Zugriff über:
#    dialog_title "Schlüsselwort"
#
# Description (English):
# This module provides window titles (dialog_title) for all interactive
# whiptail dialogs, depending on language and dialog context. Usage:
#    dialog_title "keyword"
#
###############################################################################

### Liefert den angepassten (lokalisierten) Fenstertitel für Whiptail-Dialoge
### Returns the proper (localized) title for whiptail dialogs
dialog_title() {
    local key="$1"
    local lang="${LANGCODE:-de}"   # Fallback: de

    case "$lang" in
        de)
            case "$key" in
                Hostname)         echo "Hostname eingeben" ;;
                Passwort)         echo "Passwort festlegen" ;;
                "Container-ID")   echo "Container-ID eingeben" ;;
                Fehler)           echo "Fehler" ;;
                Template)         echo "Template auswählen" ;;
                RootFS)           echo "RootFS-Größe" ;;
                CPU)              echo "CPU-Kerne" ;;
                RAM)              echo "Arbeitsspeicher" ;;
                IP)               echo "IP-Adresse" ;;
                Modus)            echo "Modusauswahl" ;;
                Update)           echo "Systemaktualisierung" ;;
                SSH)              echo "SSH-Key-Auswahl" ;;
                Dotfiles)         echo "Dotfiles-Setup" ;;
                Netz)             echo "Netzwerkkonfiguration" ;;
                Zusammenfassung)  echo "Zusammenfassung" ;;
                *)                echo "$key" ;;
            esac
            ;;
        en)
            case "$key" in
                Hostname)         echo "Enter Hostname" ;;
                Passwort)         echo "Set root password" ;;
                "Container-ID")   echo "Enter Container ID" ;;
                Fehler)           echo "Error" ;;
                Template)         echo "Select template" ;;
                RootFS)           echo "RootFS size" ;;
                CPU)              echo "CPU cores" ;;
                RAM)              echo "Memory" ;;
                IP)               echo "IP address" ;;
                Modus)            echo "Mode selection" ;;
                Update)           echo "System update" ;;
                SSH)              echo "SSH key selection" ;;
                Dotfiles)         echo "Dotfiles setup" ;;
                Netz)             echo "Network configuration" ;;
                Zusammenfassung)  echo "Summary" ;;
                *)                echo "$key" ;;
            esac
            ;;
        *)
            # Fallback: Versuche Deutsch, falls Sprache unbekannt
            case "$key" in
                Hostname)         echo "Hostname eingeben" ;;
                Passwort)         echo "Passwort festlegen" ;;
                "Container-ID")   echo "Container-ID eingeben" ;;
                Fehler)           echo "Fehler" ;;
                Template)         echo "Template auswählen" ;;
                RootFS)           echo "RootFS-Größe" ;;
                CPU)              echo "CPU-Kerne" ;;
                RAM)              echo "Arbeitsspeicher" ;;
                IP)               echo "IP-Adresse" ;;
                Modus)            echo "Modusauswahl" ;;
                Update)           echo "Systemaktualisierung" ;;
                SSH)              echo "SSH-Key-Auswahl" ;;
                Dotfiles)         echo "Dotfiles-Setup" ;;
                Netz)             echo "Netzwerkkonfiguration" ;;
                Zusammenfassung)  echo "Zusammenfassung" ;;
                *)                echo "$key" ;;
            esac
            ;;
    esac
}


### dotfiles.func

#!/usr/bin/env bash
###############################################################################
# dotfiles.func – Dotfiles-Integration für Proxmox LXC-Container
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Diese Funktion klont oder aktualisiert ein Dotfiles-Repository im LXC-Container.
# Es wird sichergestellt, dass Git installiert ist, und vorhandene Dotfiles
# werden per git pull aktualisiert.
#
# Description (English):
# This function clones or updates a Dotfiles GitHub repository inside the LXC container.
# Ensures Git is installed and existing dotfiles are updated via git pull.
#
###############################################################################

### Klone oder aktualisiere Dotfiles im Container
### Clone or update dotfiles repository inside the container
# ...existing code...
clone_dotfiles_in_container() {
    log "${MSG[dotfiles]}"
    [[ -z "${CT_ID:-}" ]] && exit_with_log "CT_ID ist nicht gesetzt."

    if pct exec "$CT_ID" -- bash -eu <<'EOF'
if ! command -v git >/dev/null 2>&1; then
    apt-get update -qq
    apt-get install -y -qq git
fi

if [ ! -d /root/dotfiles/.git ]; then
    rm -rf /root/dotfiles
    git clone https://github.com/stony64/dotfiles.git /root/dotfiles
else
    cd /root/dotfiles && git pull
fi
EOF
    then
        log_success "${MSG[dotfiles_ok]}"
    else
        log_error "${MSG[dotfiles_fail]}"
        exit 1
    fi
}


### input.func

#!/usr/bin/env bash
###############################################################################
# input.func – Interaktive Benutzereingaben für Proxmox LXC Creator
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Dieses Modul behandelt alle interaktiven whiptail-Eingaben, z. B.
# Hostname, Passwort, Container-ID, Template, RootFS, Ressourcen und IP.
#
# Description (English):
# This module manages all interactive user prompts via whiptail, including
# hostname, password, container ID, template, rootfs, resources, and IP address.
###############################################################################

###############################################################################
# Interaktive Eingabefunktionen für den Installer-Workflow
###############################################################################

### Container-ID eingeben/anzeigen (optional bei automatischer Vergabe)
### Prompt for custom CT-ID (optional if auto-assigned)
input_ctid() {
    CT_ID=$(whiptail --title "$(dialog_title "Container-ID")" \
        --inputbox "${MSG[ctid_prompt]:-Bitte Container-ID eingeben:}" 8 60 "$CT_ID" 3>&1 1>&2 2>&3) \
        || exit_with_log "${MSG[abort]}"
    log "${MSG[ctid_assigned]} $CT_ID"
}

### Hostname interaktiv abfragen oder CLI-Wert übernehmen
### Prompt for hostname or accept CLI parameter
input_hostname() {
    if [[ -n "$PARAM_HOSTNAME" ]]; then
        CT_HOSTNAME="$PARAM_HOSTNAME"
        log "Verwende übergebenen Hostname: $CT_HOSTNAME"
        return
    fi
    while true; do
        CT_HOSTNAME=$(whiptail --title "$(dialog_title Hostname)" \
            --inputbox "${MSG[hostname]}" 10 60 "" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
        if [[ -z "$CT_HOSTNAME" ]]; then
            whiptail --title "$(dialog_title Fehler)" --msgbox "${MSG[input_empty]}" 8 60
            continue
        fi
        # Hostname nach RFC prüfen
        if [[ "$CT_HOSTNAME" =~ ^[a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?$ ]]; then
            break
        else
            whiptail --title "$(dialog_title Fehler)" --msgbox "${MSG[input_invalid]}" 8 60
        fi
    done
    log "${MSG[hostname]} $CT_HOSTNAME"
}

### Passwort sicher abfragen (mindestens 8 Zeichen)
### Prompt for root password and validate minimum length
input_password() {
    while true; do
        CT_PASSWORD=$(whiptail --title "$(dialog_title Passwort)" \
            --passwordbox "${MSG[password]}" 10 60 "" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
        if [[ -z "$CT_PASSWORD" || ${#CT_PASSWORD} -lt 8 ]]; then
            whiptail --title "$(dialog_title Fehler)" --msgbox "${MSG[input_invalid]}" 8 60
            continue
        fi
        break
    done
    log "${MSG[password]} wurde erfolgreich gesetzt."
}

### Template-Auswahl via Menü
### Display template list and let user select one
select_template() {
    log "${MSG[template_select]} $TEMPLATE_PATH"
    mapfile -t templates < <(find "$TEMPLATE_PATH" -maxdepth 1 -type f -name '*-standard_*.tar.zst' | sort)
    [[ ${#templates[@]} -eq 0 ]] && exit_with_log "${MSG[template_none]}"
    local menu_items=()
    for tpl_path in "${templates[@]}"; do
        tpl_file=$(basename "$tpl_path")
        menu_items+=("$tpl_file" "")
    done
    TEMPLATE_FILE=$(whiptail --title "$(dialog_title Template)" \
        --menu "${MSG[template_select]}" 20 70 10 "${menu_items[@]}" 3>&1 1>&2 2>&3) \
        || exit_with_log "${MSG[abort]}"
    OSTEMPLATE="${TEMPLATE_PATH}/${TEMPLATE_FILE}"
    export OSTEMPLATE
    log "${MSG[template_chosen]/%s/$TEMPLATE_FILE}"
}

### RootFS-Größe interaktiv erfragen (in GB, Ganzzahl)
### Prompt for root filesystem size in GB (integer)
input_rootfs_size() {
    ROOTFS_SIZE=$(whiptail --title "$(dialog_title RootFS)" \
        --inputbox "${MSG[rootfs]}" 8 50 "2" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
    if ! [[ "$ROOTFS_SIZE" =~ ^[1-9][0-9]*$ ]]; then
        whiptail --title "$(dialog_title Fehler)" --msgbox "${MSG[input_invalid]}" 8 60
        input_rootfs_size
        return
    fi
    log "${MSG[rootfs]}: $ROOTFS_SIZE GB"
}

### CPU-/RAM-Ressourcen interaktiv abfragen
### Prompt for CPU cores and RAM allocation
input_resources() {
    CT_CORES=$(whiptail --title "$(dialog_title CPU)" \
        --inputbox "${MSG[cores]}" 8 50 "1" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
    if ! [[ "$CT_CORES" =~ ^[1-9][0-9]*$ ]]; then
        whiptail --title "$(dialog_title Fehler)" --msgbox "${MSG[input_invalid]}" 8 60
        input_resources
        return
    fi
    CT_MEMORY=$(whiptail --title "$(dialog_title RAM)" \
        --inputbox "${MSG[memory]}" 8 50 "512" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
    if ! [[ "$CT_MEMORY" =~ ^[1-9][0-9]*$ ]]; then
        whiptail --title "$(dialog_title Fehler)" --msgbox "${MSG[input_invalid]}" 8 60
        input_resources
        return
    fi
    log "${MSG[cores]}: $CT_CORES, ${MSG[memory]}: $CT_MEMORY MB"
}

### Modusauswahl (derzeit Einzelmodus/Abbruch)
### Select mode (currently only single/cancel)
select_mode() {
    local mode
    mode=$(whiptail --title "${MSG[mode_title]}" \
        --menu "${MSG[choose_type]}" 12 60 2 \
        "single" "${MSG[desc_single]}" \
        "cancel" "${MSG[mode_cancel]}" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
    case "$mode" in
        single)
            log "${MSG[mode_selected_single]}"
            ;;
        cancel)
            exit_with_log "${MSG[abort]}"
            ;;
        *)
            exit_with_log "Unbekannter Modus: $mode"
            ;;
    esac
}

### Nächste freie LXC-Container-ID finden
### Find next free LXC container ID
find_next_ctid() {
    local last_id
    last_id=$(pct list | awk 'NR>1 {print $1}' | sort -n | tail -n1)
    if [[ -z "$last_id" ]]; then
        CT_ID=100
    else
        CT_ID=$((last_id + 1))
    fi
    log "${MSG[ctid_assigned]} $CT_ID"
}

### OS-Typ aus Template-Filename bestimmen
### Detect OSType automatically from selected template filename
detect_ostype_from_template() {
    local template="${TEMPLATE_FILE:-}"
    if [[ -z "$template" ]]; then
        exit_with_log "${MSG[ostype_unknown]:-Fehler: OS-Typ nicht erkannt!}"
    fi
    if [[ "$template" =~ ^([a-zA-Z0-9]+)- ]]; then
        OSType="${BASH_REMATCH[1]}"
    else
        OSType=""
        exit_with_log "${MSG[ostype_unknown]:-Fehler: OS-Typ im Template nicht erkannt!}"
    fi
    log "${MSG[ostype_detected]:-OS-Typ erkannt:} $OSType"
}


### logging.func

#!/usr/bin/env bash
###############################################################################
# logging.func – Zentrale Logging-Funktionen für Proxmox LXC-Ersteller
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Diese Datei stellt zentrale Logging-Funktionen für das Skript bereit.
# Protokolle werden sowohl im Terminal als auch in der LOGDATEI ausgegeben.
#
# Description (English):
# This file provides central logging functions for the Proxmox LXC creator.
# Output is written both to the console and to the log file defined in $LOGFILE.
#
###############################################################################

### Ausgabe in Konsole und Logdatei schreiben
### Log line to stdout and log file
log() {
    echo "[INFO] $1" | tee -a "$LOGFILE"
}

### Erfolgreiche Aktion loggen
### Log successful operation
log_success() {
    echo "[OK]   $1" | tee -a "$LOGFILE"
}

### Fehlerhafte Aktion loggen
### Log error to console and file
log_error() {
    echo "[ERROR] $1" | tee -a "$LOGFILE"
}

### Loggt Fehlermeldung und bricht Skript ab (DE/EN)
### Logs error message and exits script
exit_with_log() {
    local msg="${1:-[Unbekannter Fehler/Unknown error]}"
    log_error "$msg"
    exit 1
}


### network.func

#!/usr/bin/env bash
###############################################################################
# network.func – IP-Handling für LXC-Container
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Diese Datei enthält Funktionen zur Eingabe und Validierung von IP-Adressen,
# insbesondere zur Vergabe eines statischen letzten Oktetts für IPv4 und IPv6
# basierend auf einem konfigurierten Subnetz-Basiswert.
#
# Description (English):
# This file contains utility functions for input and validation of IPv4/IPv6
# addresses. It is used to assign static addresses by prompting the user for
# the last octet of an IP address and constructing full IPv4 and IPv6 values
# using predefined base prefixes.
#
###############################################################################

### Prüft, ob das gewünschte IPv4-Oktett bereits vergeben ist
### Returns 0 if octet is free, 1 if already in use
is_ip_octet_in_use() {
    local octet="$1"
    local ip="${BASE_IPV4}${octet}"
    # Extrahiere alle IPv4-Adressen aus bestehenden Containern
    pct list -o net | awk -F'[=,]' '/ip=/{print $2}' | grep -qx "$ip"
}

### Eingabe: Letztes IPv4-Oktett abfragen und IP-Adressen zusammensetzen
### Input last IPv4 octet and calculate full static addresses
get_container_ip() {
    local last_octet=""
    while true; do
        last_octet=$(whiptail --inputbox "${MSG[octet]}" 10 50 "" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"

        if ! validate_ip_octet "$last_octet"; then
            whiptail --msgbox "${MSG[input_invalid]}" 8 60
            continue
        fi

        if is_ip_octet_in_use "$last_octet"; then
            whiptail --msgbox "${MSG[ip_in_use]:-IP bereits vergeben!}" 8 60
            continue
        fi

        break
    done

    CT_IPV4="${BASE_IPV4}${last_octet}"
    CT_IPV6="${BASE_IPV6}${last_octet}"
    log "IPv4: $CT_IPV4, IPv6: $CT_IPV6"
}

### Prüft, ob ein Wert ein gültiges IPv4-Oktett (0–255) ist
### Returns 0 if valid IPv4 octet [0–255], 1 otherwise
validate_ip_octet() {
    [[ "$1" =~ ^([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])$ ]]
}



### proxmox-lxc-create.sh

#!/usr/bin/env bash
###############################################################################
# proxmox-lxc-create.sh
# -----------------------------------------------------------
# Dieses Skript sammelt alle *.sh und *.func-Dateien im aktuellen Projekt-
# verzeichnis (rekursiv) und schreibt sie in eine Sammeldatei. Die Verzeichnisse
# .git und .vscode werden ignoriert.
#
# This script collects all *.sh and *.func files in the current project directory
# (recursively) and writes them into a single bundle file. The directories .git
# and .vscode are excluded.
#
# Autor/Author: Dein Name
# Datum/Date: 2025-07-20
###############################################################################

OUTPUT="proxmox-lxc-create.txt"

# Leere Ausgabedatei erzeugen / Create empty output file
: > "$OUTPUT"

# Alle relevanten Dateien suchen (rekursiv), .git und .vscode ausschließen
# Find all relevant files recursively, exclude .git and .vscode
find . \
  \( -path '*/.git/*' -o -path '*/.vscode/*' \) -prune -o \
  -type f \( -name '*.sh' -o -name '*.func' \) -print | sort | while read -r f; do
    rel_path="${f#./}"
    # Header für jede Datei / Header for each file
    {
        echo "### $rel_path"
        echo
        cat "$f"
        echo
        echo
    } >> "$OUTPUT"
done

echo "Fertig! Sammeldatei: $OUTPUT"
echo "Done! Bundle file: $OUTPUT"


### security.func

#!/usr/bin/env bash
###############################################################################
# security.func – Sicherheitsprüfungen für Proxmox LXC Creator
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Prüft wichtige Voraussetzungen: root-Rechte, Bash-Version, Tools, Pfade.
#
# Description (English):
# Ensures script prerequisites: root, bash version, required tools, paths.
#
###############################################################################

### Prüfen, ob das Skript als root ausgeführt wird
### Ensure script is executed as root
check_root() {
    [[ "$EUID" -ne 0 ]] && exit_with_log "Dieses Skript muss als root ausgeführt werden."
}

check_bash_version() {
    if [[ -z "${BASH_VERSINFO[0]:-}" || -z "${BASH_VERSINFO[1]:-}" ]]; then
        exit_with_log "${MSG[abort]:-BASH_VERSINFO nicht verfügbar – bitte Skript mit bash ausführen.}"
    fi

    local bash_major="${BASH_VERSINFO[0]}"
    local bash_minor="${BASH_VERSINFO[1]}"

    if ! [[ "$bash_major" =~ ^[0-9]+$ ]] || ! [[ "$bash_minor" =~ ^[0-9]+$ ]]; then
        exit_with_log "Bash-Version nicht numerisch auswertbar: $bash_major.$bash_minor"
    fi

    if (( bash_major < 4 )); then
        exit_with_log "Bash $bash_major.$bash_minor zu alt – mindestens 4.0 erforderlich."
    fi
}

check_required_tools() {
    local tools=("whiptail" "pct" "git")
    for tool in "${tools[@]}"; do
        command -v "$tool" &>/dev/null || exit_with_log "Benötigtes Tool '$tool' fehlt."
    done
}

check_directory_exists() {
    local dirpath="$1"
    if [[ ! -d "$dirpath" ]]; then
        log_error "Verzeichnis nicht gefunden: $dirpath"
        log_error "Directory not found: $dirpath"
        exit 1
    fi
}


### ssh.func

#!/usr/bin/env bash
###############################################################################
# ssh.func – SSH-Key-Suche und Setup für Proxmox LXC
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Diese Datei enthält Funktionen zur Suche, Prüfung und Bereitstellung
# eines SSH Public Keys anhand eines Kommentars. Der Key wird entweder vor dem
# Start direkt ins Root-FS geschrieben oder nach dem Start via pct exec injiziert.
#
# Description (English):
# This module handles locating, validating, and preparing a public SSH key
# based on a comment string. The key is either placed directly into the root
# filesystem or injected into the container after startup.
#
###############################################################################

### Kommentarzeichenkette vom Nutzer zur SSH-Key-Suche abfragen
### Ask user for identifying comment of SSH public key
ask_for_laptop_key_comment() {
    LAPTOP_KEY_COMMENT=$(whiptail --title "$(dialog_title SSH)" \
        --inputbox "${MSG[ssh_comment_prompt]}" 10 70 "" 3>&1 1>&2 2>&3) \
        || exit_with_log "${MSG[abort]}"

    [[ -z "$LAPTOP_KEY_COMMENT" ]] && exit_with_log "${MSG[input_empty]}"
    log "${MSG[ssh_lookup]}: $LAPTOP_KEY_COMMENT"
}

### SSH-Key aus authorized_keys suchen und lokal in Datei zwischenspeichern
### Locate matching SSH key by comment and write to temp file
extract_laptop_key() {
    local authfile="/root/.ssh/authorized_keys"
    [[ ! -f "$authfile" ]] && exit_with_log "authorized_keys nicht gefunden unter: $authfile"

    local key_match
    key_match=$(grep -m1 "$LAPTOP_KEY_COMMENT" "$authfile" || true)

    if [[ "$key_match" =~ ^ssh-(rsa|ed25519|ecdsa) ]]; then
        SSH_PUBKEY=$(mktemp "/tmp/lxc_ssh_${CT_ID}_XXXXXXXX.pub")
        echo "$key_match" > "$SSH_PUBKEY"
        chmod 600 "$SSH_PUBKEY"
        log_success "${MSG[ssh_found]}"
    else
        whiptail --title "$(dialog_title SSH)" --msgbox "${MSG[ssh_not_found]}" 8 60
        SSH_PUBKEY=""
    fi
}

### Key vor dem Start direkt in das RootFS des Containers einfügen
### Copy key directly into root FS before container is started
prepare_ssh_key_prestart() {
    if [[ -n "$SSH_PUBKEY" && -f "$SSH_PUBKEY" ]]; then
        local ssh_dir="/var/lib/lxc/$CT_ID/rootfs/root/.ssh"
        mkdir -p "$ssh_dir"
        cp "$SSH_PUBKEY" "$ssh_dir/authorized_keys"
        chmod 700 "$ssh_dir"
        chmod 600 "$ssh_dir/authorized_keys"
        chown root:root "$ssh_dir" "$ssh_dir/authorized_keys"
        log "${MSG[ssh_setup]}"
    fi
}

### SSH-Key nach dem Start in den laufenden Container injizieren
### Push SSH key into running container, fallback to password auth if missing
finalize_ssh_key_after_start() {
    if [[ -n "$SSH_PUBKEY" && -f "$SSH_PUBKEY" ]]; then
        pct exec "$CT_ID" -- bash -c '
            mkdir -p /root/.ssh
            cat > /root/.ssh/authorized_keys < /dev/stdin
            chmod 600 /root/.ssh/authorized_keys
            chown root:root /root/.ssh/authorized_keys
        ' < "$SSH_PUBKEY"

        log_success "${MSG[ssh_setup]}"
    else
        # Fallback aktivieren: Root-Login via Passwort erlauben
        pct exec "$CT_ID" -- bash -c '
            sed -i "s/^#*PermitRootLogin.*/PermitRootLogin yes/" /etc/ssh/sshd_config
            sed -i "s/^#*PasswordAuthentication.*/PasswordAuthentication yes/" /etc/ssh/sshd_config
            systemctl restart ssh || systemctl restart sshd || true
        '

        log "${MSG[ssh_temp]}"
    fi
}


### summary.func

#!/usr/bin/env bash
###############################################################################
# summary.func – Abschlussanzeige / Containerdaten
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Diese Datei zeigt nach Abschluss der Container-Erstellung die wichtigsten
# Parameter in strukturierter Form zur sofortigen Übersicht an.
#
# Description (English):
# This module prints a structured summary of all relevant container values
# after successful creation and configuration — for CLI and documentation.
#
###############################################################################

### Gibt eine Übersicht der CT-Parameter nach Erstellung auf Konsole aus
### Prints container summary to console after creation
print_summary() {
    echo
    # Mehrsprachige Überschrift
    if [[ "${LANGCODE:-de}" == "en" ]]; then
        echo "Container created successfully"
        echo "----------------------------------------"
        echo "CT ID:          ${CT_ID:-<not set>}"
        echo "Hostname:       ${CT_HOSTNAME:-<not set>}"
        echo "OS type:        ${OSType:-<not set>}"
        echo "Template:       ${TEMPLATE_FILE:-<not set>}"
        echo "CPU cores:      ${CT_CORES:-<not set>}"
        echo "RAM:            ${CT_MEMORY:-<not set>} MB"
        echo "RootFS:         ${ROOTFS_SIZE:-<not set>} GB"
        echo "IPv4 address:   ${CT_IPV4:-<not set>}"
        echo "IPv4 gateway:   ${GATEWAY_IPV4:-<not set>}"
        echo "IPv6 address:   ${CT_IPV6:-<not set>}"
        echo "IPv6 gateway:   ${GATEWAY_IPV6:-<not set>}"
        echo "----------------------------------------"
        echo "Access: pct enter ${CT_ID:-<not set>}  or  ssh root@${CT_IPV4:-<not set>}"
        echo
    else
        echo "Container erfolgreich erstellt"
        echo "----------------------------------------"
        echo "CT-ID:          ${CT_ID:-<nicht gesetzt>}"
        echo "Hostname:       ${CT_HOSTNAME:-<nicht gesetzt>}"
        echo "OS-Typ:         ${OSType:-<nicht gesetzt>}"
        echo "Template:       ${TEMPLATE_FILE:-<nicht gesetzt>}"
        echo "CPU-Kerne:      ${CT_CORES:-<nicht gesetzt>}"
        echo "RAM:            ${CT_MEMORY:-<nicht gesetzt>} MB"
        echo "RootFS:         ${ROOTFS_SIZE:-<nicht gesetzt>} GB"
        echo "IPv4-Adresse:   ${CT_IPV4:-<nicht gesetzt>}"
        echo "IPv4-Gateway:   ${GATEWAY_IPV4:-<nicht gesetzt>}"
        echo "IPv6-Adresse:   ${CT_IPV6:-<nicht gesetzt>}"
        echo "IPv6-Gateway:   ${GATEWAY_IPV6:-<nicht gesetzt>}"
        echo "----------------------------------------"
        echo "Zugriff: pct enter ${CT_ID:-<nicht gesetzt>}  oder  ssh root@${CT_IPV4:-<nicht gesetzt>}"
        echo
    fi
}


### system.func

#!/usr/bin/env bash
###############################################################################
# system.func – Systempflege und Konfiguration im LXC-Container
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Diese Datei enthält Funktionen zur Systemkonfiguration innerhalb eines
# LXC-Containers nach dessen Erstellung. Dazu gehören Locale-, Zeitzonen- und
# APT-Update-Prozesse.
#
# Description (English):
# This file provides post-creation system configuration steps for LXC containers,
# such as setting locales and timezone, and running APT updates.
#
###############################################################################

### Locales und Zeitzone im Container setzen
### Configure system locales and timezone in the container
configure_locales() {
    log "${MSG[locales]}"
    log "${MSG[timezone]}"

    if pct exec "$CT_ID" -- apt-get install -y -qq locales tzdata &&
       pct exec "$CT_ID" -- bash -c "echo 'en_US.UTF-8 UTF-8' >> /etc/locale.gen; echo 'de_DE.UTF-8 UTF-8' >> /etc/locale.gen; locale-gen" &&
       pct exec "$CT_ID" -- update-locale LANG=de_DE.UTF-8 &&
       pct exec "$CT_ID" -- ln -sf /usr/share/zoneinfo/Europe/Berlin /etc/localtime &&
       pct exec "$CT_ID" -- bash -c 'echo "Europe/Berlin" > /etc/timezone'
    then
        log_success "${MSG[locales_ok]}"
        log_success "${MSG[timezone_ok]}"
    else
        log_error "${MSG[locales_fail]}"
        log_error "${MSG[timezone_fail]}"
        exit 1
    fi
}

### APT-Update im Container durchführen
### Run apt update/upgrade/autoremove/clean in the container
update_container() {
    log "${MSG[update]}"

    if pct exec "$CT_ID" -- bash -c '
        export DEBIAN_FRONTEND=noninteractive
        apt-get update -qq &&
        apt-get upgrade -y -qq &&
        apt-get autoremove -y -qq &&
        apt-get clean -qq
    '
    then
        log_success "${MSG[update_ok]}"
    else
        log_error "${MSG[update_fail]}"
        exit 1
    fi
}


### translation.func

#!/usr/bin/env bash
###############################################################################
# translation.func – Mehrsprachigkeit für Proxmox LXC Creator
# Version:    2.7.6
# Datum:      2025-07-21
#
# Dieses Modul initialisiert das assoziative Array MSG mit allen UI-Texten für
# Deutsch und Englisch. Es wird innerhalb des Hauptskripts über load_translations
# eingebunden. Eine vollständige Initialisierung aller Keys ist gewährleistet.
###############################################################################

# shellcheck disable=SC2034
declare -A MSG

### Sprache laden: whiptail-Dialog, Fallback bei Fehler
load_translations() {
    if ! command -v whiptail &>/dev/null || [[ ! -t 1 ]]; then
        echo "WARNUNG: Keine Terminalunterstützung – Standardsprache: Englisch" >&2
        set_default_english
        return
    fi

    local lang
    lang=$(whiptail --menu "Sprache wählen / Choose language:" 12 40 2 \
        "de" "Deutsch" \
        "en" "English" 3>&1 1>&2 2>&3)

    if [[ $? -ne 0 || -z "$lang" ]]; then
        whiptail --title "Abbruch / Cancelled" \
            --msgbox "Keine Auswahl – Standard: Englisch." 8 60 || echo "Fallback auf Englisch"
        set_default_english
    else
        export LANGCODE="$lang"
        [[ "$lang" == "de" ]] && set_default_german || set_default_english
    fi
}

###############################################################################
# Deutsch
###############################################################################
set_default_german() {
    # Allgemein & Fehler
    MSG[abort]="Vorgang abgebrochen."
    MSG[input_empty]="Eingabe darf nicht leer sein."
    MSG[input_invalid]="Ungültige Eingabe. Bitte erneut versuchen."

    # Root-Check
    MSG[root_required]="Dieses Skript muss als root ausgeführt werden."
    MSG[root_ok]="Root-Rechte bestätigt."

    # Moduswahl
    MSG[mode_title]="Modusauswahl"
    MSG[choose_type]="Bitte Container-Modus wählen:"
    MSG[mode_single]="Einzeln"
    MSG[mode_cancel]="Abbrechen"
    MSG[desc_single]="Einen einzelnen Container anlegen"
    MSG[mode_selected_single]="Einzelmodus gewählt."

    # Hostname, Passwort, CT-ID
    MSG[hostname]="Hostname für den Container eingeben:"
    MSG[password]="Root-Passwort (min. 8 Zeichen):"
    MSG[ctid_prompt]="Container-ID eingeben:"
    MSG[ctid_assigned]="Vergebene Container-ID:"
    MSG[ctid_none]="Keine freie CT-ID gefunden!"

    # Template & OS
    MSG[template_select]="Template auswählen:"
    MSG[template_none]="Keine Template-Dateien gefunden!"
    MSG[template_chosen]="Verwendetes Template: %s"
    MSG[ostype_detected]="OS-Typ erkannt:"
    MSG[ostype_unknown]="Fehler: OS-Typ im Template-Dateinamen nicht erkannt."

    # Ressourcen
    MSG[rootfs]="RootFS-Größe (GB)"
    MSG[cores]="CPU-Kerne"
    MSG[memory]="Arbeitsspeicher (MB)"

    # Netzwerk / IP-Adressen
    MSG[octet]="Letzte Stelle der IPv4-Adresse eingeben (z. B. 42):"
    MSG[ip_in_use]="Diese IP-Adresse ist bereits einem anderen Container zugewiesen!"

    # Container-Erstellung
    MSG[creating]="Container wird erstellt..."
    MSG[created]="Container wurde erfolgreich erstellt."
    MSG[started]="Container wurde gestartet."

    # SSH
    MSG[ssh_comment_prompt]="SSH-Key-Kommentar eingeben (z. B. user@laptop):"
    MSG[ssh_lookup]="Suche SSH-Key mit Kommentar"
    MSG[ssh_found]="SSH-Key wurde erkannt und übernommen."
    MSG[ssh_not_found]="Kein passender SSH-Key mit Kommentar gefunden."
    MSG[ssh_setup]="SSH-Key erfolgreich im Container gespeichert."
    MSG[ssh_temp]="Kein SSH-Key – Root-Login per Passwort bleibt aktiv."

    # Systemkonfiguration
    MSG[locales]="Locales und Systemsprachen werden installiert..."
    MSG[locales_ok]="Locales erfolgreich eingerichtet."
    MSG[locales_fail]="Fehler bei der Einrichtung der Locales!"
    MSG[timezone]="Setze Zeitzone auf Europe/Berlin..."
    MSG[timezone_ok]="Zeitzone erfolgreich gesetzt."
    MSG[timezone_fail]="Fehler beim Setzen der Zeitzone!"

    # Systemupdate
    MSG[update]="Führe Systemupdate im Container durch..."
    MSG[update_ok]="Container erfolgreich aktualisiert."
    MSG[update_fail]="Systemupdate im Container fehlgeschlagen."

    # Dotfiles
    MSG[dotfiles]="Dotfiles werden im Container geklont..."
    MSG[dotfiles_ok]="Dotfiles erfolgreich aktualisiert."
    MSG[dotfiles_fail]="Fehler beim Klonen der Dotfiles!"

    # Vorschau/Dry-Run
    MSG[preview]="[Vorschau] – Kein Container wird erstellt."
}


###############################################################################
# Englisch
###############################################################################
set_default_english() {
    # General & Errors
    MSG[abort]="Operation aborted."
    MSG[input_empty]="Input must not be empty."
    MSG[input_invalid]="Invalid input. Please try again."

    # Root check
    MSG[root_required]="This script must be run as root."
    MSG[root_ok]="Root access confirmed."

    # Mode selection
    MSG[mode_title]="Mode selection"
    MSG[choose_type]="Select container mode:"
    MSG[mode_single]="Single"
    MSG[mode_cancel]="Cancel"
    MSG[desc_single]="Create a single container"
    MSG[mode_selected_single]="Single mode selected."

    # Hostname, password, CT ID
    MSG[hostname]="Enter container hostname:"
    MSG[password]="Root password (min. 8 characters):"
    MSG[ctid_prompt]="Enter container ID:"
    MSG[ctid_assigned]="Assigned container ID:"
    MSG[ctid_none]="No free container ID found!"

    # Template & OS
    MSG[template_select]="Select template:"
    MSG[template_none]="No template files found!"
    MSG[template_chosen]="Selected template: %s"
    MSG[ostype_detected]="OS type detected:"
    MSG[ostype_unknown]="Error: OS type could not be determined from filename."

    # Resources
    MSG[rootfs]="Root filesystem size (GB)"
    MSG[cores]="CPU cores"
    MSG[memory]="Memory (MB)"

    # Network / IP
    MSG[octet]="Enter the last octet of the IPv4 address (e.g. 42):"
    MSG[ip_in_use]="This IP address is already assigned to another container!"

    # Container creation
    MSG[creating]="Creating container..."
    MSG[created]="Container created successfully."
    MSG[started]="Container has been started."

    # SSH
    MSG[ssh_comment_prompt]="Enter comment of SSH public key (e.g. user@laptop):"
    MSG[ssh_lookup]="Looking for SSH key with comment"
    MSG[ssh_found]="SSH key found and applied."
    MSG[ssh_not_found]="No matching SSH key with comment found."
    MSG[ssh_setup]="SSH key successfully saved to container."
    MSG[ssh_temp]="No valid SSH key – root login via password remains active."

    # System configuration
    MSG[locales]="Installing system locales and languages..."
    MSG[locales_ok]="Locales successfully configured."
    MSG[locales_fail]="Locale configuration failed!"
    MSG[timezone]="Setting timezone to Europe/Berlin..."
    MSG[timezone_ok]="Timezone successfully set."
    MSG[timezone_fail]="Failed to set timezone in container!"

    # System update
    MSG[update]="Running system update in container..."
    MSG[update_ok]="Container updated successfully."
    MSG[update_fail]="System update failed in container."

    # Dotfiles
    MSG[dotfiles]="Cloning dotfiles inside the container..."
    MSG[dotfiles_ok]="Dotfiles updated successfully."
    MSG[dotfiles_fail]="Error cloning dotfiles inside the container!"

    # Preview / Dry-run
    MSG[preview]="[Preview] – No container will be created."
}


