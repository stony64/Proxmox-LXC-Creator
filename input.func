#!/usr/bin/env bash
###############################################################################
# input.func – Interaktive Benutzereingaben für Proxmox LXC Creator
# Version:    2.7.5
# Datum:      2025-07-21
#
# Beschreibung (Deutsch):
# Dieses Modul behandelt sämtliche interaktiven Eingaben (whiptail),
# wie Hostname, Passwort, Container-ID, Template, Ressourcen, IP-Adressen.
#
# Description (English):
# This module handles all interactive user prompts (via whiptail)
# for hostname, password, container ID, template, resource and IP selection.
###############################################################################

###############################################################################
# Hilfsfunktion: Lokalisierte Überschriften für whiptail-Dialoge
###############################################################################
dialog_title() {
    # Verwendet ggf. Übersetzungstabelle aus MSG[], sonst Rückfall auf Eingabe
    local key="$1"
    case "$LANGCODE" in
        de) printf "%s" "$key" ;;
        en) printf "%s" "$key" ;;
        *)  printf "%s" "$key" ;;
    esac
}

###############################################################################
# Interaktive Eingabefunktionen
###############################################################################

### Container-ID eingeben/anzeigen (falls nicht automatisch vergeben)
### Prompt for custom CT-ID (optional if auto-assigned)
input_ctid() {
    CT_ID=$(whiptail --title "$(dialog_title Container-ID)" \
        --inputbox "${MSG[ctid_prompt]:-Bitte Container-ID eingeben:}" 8 60 "$CT_ID" 3>&1 1>&2 2>&3) \
        || exit_with_log "${MSG[abort]}"
    log "${MSG[ctid_assigned]} $CT_ID"
}

### Hostname abfragen / übernehmen
### Prompt for hostname or accept CLI parameter
input_hostname() {
    if [[ -n "$PARAM_HOSTNAME" ]]; then
        CT_HOSTNAME="$PARAM_HOSTNAME"
        log "Verwende übergebenen Hostname: $CT_HOSTNAME"
        return
    fi
    while true; do
        CT_HOSTNAME=$(whiptail --title "$(dialog_title Hostname)" \
            --inputbox "${MSG[hostname]}" 10 60 "" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
        if [[ -z "$CT_HOSTNAME" ]]; then
            whiptail --title "$(dialog_title Fehler)" \
                --msgbox "${MSG[input_empty]}" 8 60
            continue
        fi
        # Hostname-Validierung: RFC-konform
        if [[ "$CT_HOSTNAME" =~ ^[a-zA-Z0-9]([-a-zA-Z0-9]*[a-zA-Z0-9])?$ ]]; then
            break
        else
            whiptail --title "$(dialog_title Fehler)" \
                --msgbox "${MSG[input_invalid]}" 8 60
        fi
    done
    log "${MSG[hostname]} $CT_HOSTNAME"
}

### Passwort für root abfragen
### Prompt for root password and validate length
input_password() {
    while true; do
        CT_PASSWORD=$(whiptail --title "$(dialog_title Passwort)" \
            --passwordbox "${MSG[password]}" 10 60 "" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
        if [[ -z "$CT_PASSWORD" || ${#CT_PASSWORD} -lt 8 ]]; then
            whiptail --title "$(dialog_title Fehler)" \
                --msgbox "${MSG[input_invalid]}" 8 60
            continue
        fi
        break
    done
    log "${MSG[password]} wurde erfolgreich gesetzt."
}

### Template-Auswahl via whiptail-Menü
### Display template files and let user select one
select_template() {
    log "${MSG[template_select]} $TEMPLATE_PATH"
    # Find templates *.tar.zst im Verzeichnis
    mapfile -t templates < <(find "$TEMPLATE_PATH" -maxdepth 1 -type f -name '*-standard_*.tar.zst' | sort)
    [[ ${#templates[@]} -eq 0 ]] && exit_with_log "${MSG[template_none]}"
    local menu_items=()
    for tpl_path in "${templates[@]}"; do
        tpl_file=$(basename "$tpl_path")
        menu_items+=("$tpl_file" "")
    done
    TEMPLATE_FILE=$(whiptail --title "$(dialog_title Template)" \
        --menu "${MSG[template_select]}" 20 70 10 "${menu_items[@]}" 3>&1 1>&2 2>&3) \
        || exit_with_log "${MSG[abort]}"
    OSTEMPLATE="${TEMPLATE_PATH}/${TEMPLATE_FILE}"
    export OSTEMPLATE
    log "${MSG[template_chosen]} $TEMPLATE_FILE"
}

### RootFS-Größe interaktiv abfragen (in GB)
### Prompt for rootfs size in GB
input_rootfs_size() {
    ROOTFS_SIZE=$(whiptail --title "$(dialog_title RootFS)" \
        --inputbox "${MSG[rootfs]}" 8 50 "2" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
    if ! [[ "$ROOTFS_SIZE" =~ ^[1-9][0-9]*$ ]]; then
        whiptail --title "$(dialog_title Fehler)" \
            --msgbox "${MSG[input_invalid]}" 8 60
        input_rootfs_size
        return
    fi
    log "${MSG[rootfs]}: $ROOTFS_SIZE GB"
}

### CPU- und RAM-Angabe erfragen
### Prompt for CPU cores and memory allocation
input_resources() {
    CT_CORES=$(whiptail --title "$(dialog_title CPU)" \
        --inputbox "${MSG[cores]}" 8 50 "1" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
    if ! [[ "$CT_CORES" =~ ^[1-9][0-9]*$ ]]; then
        whiptail --title "$(dialog_title Fehler)" \
            --msgbox "${MSG[input_invalid]}" 8 60
        input_resources
        return
    fi
    CT_MEMORY=$(whiptail --title "$(dialog_title RAM)" \
        --inputbox "${MSG[memory]}" 8 50 "512" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
    if ! [[ "$CT_MEMORY" =~ ^[1-9][0-9]*$ ]]; then
        whiptail --title "$(dialog_title Fehler)" \
            --msgbox "${MSG[input_invalid]}" 8 60
        input_resources
        return
    fi
    log "${MSG[cores]}: $CT_CORES, ${MSG[memory]}: $CT_MEMORY MB"
}

### IP-Oktett abfragen und IP-Adressen zusammensetzen
### Ask for last IPv4 octet and construct CT_IPV4 and CT_IPV6
get_container_ip() {
    local last_octet
    while true; do
        last_octet=$(whiptail --title "$(dialog_title IP)" \
            --inputbox "${MSG[octet]}" 10 50 "" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
        if [[ "$last_octet" =~ ^([0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])$ ]]; then
            break
        fi
        whiptail --title "$(dialog_title Fehler)" --msgbox "${MSG[input_invalid]}" 8 60
    done
    CT_IPV4="${BASE_IPV4}${last_octet}"
    CT_IPV6="${BASE_IPV6}${last_octet}"
    log "IPv4: $CT_IPV4, IPv6: $CT_IPV6"
}

### Beispiel für einen Modus-Auswahl-Dialog (kann modular erweitert werden)
### Sample mode selection (extensible)
select_mode() {
    local mode
    mode=$(whiptail --title "${MSG[mode_title]}" \
        --menu "${MSG[choose_type]}" 12 60 2 \
        "single" "${MSG[desc_single]}" \
        "cancel" "${MSG[mode_cancel]}" 3>&1 1>&2 2>&3) || exit_with_log "${MSG[abort]}"
    case "$mode" in
        single)
            log "${MSG[mode_selected_single]}"
            ;;
        cancel)
            exit_with_log "${MSG[abort]}"
            ;;
        *)
            exit_with_log "Unbekannter Modus: $mode"
            ;;
    esac
}

### Nächste verfügbare CT-ID finden (optional, falls nicht extern gesetzt)
### Find next free CT-ID (if not externally managed)
find_next_ctid() {
    local last_id
    last_id=$(pct list | awk 'NR>1 {print $1}' | sort -n | tail -n1)
    if [[ -z "$last_id" ]]; then
        CT_ID=100
    else
        CT_ID=$((last_id + 1))
    fi
    log "${MSG[ctid_assigned]} $CT_ID"
}
